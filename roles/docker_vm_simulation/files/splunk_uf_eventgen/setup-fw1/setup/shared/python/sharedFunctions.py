from optparse import OptionParser
import commands
import os
import sys
import pwd
import subprocess
import shlex

# Contains functions shared by all of the setup programs
# DO NOT EXECUTE this code!

# *** Questions? lguinn@splunk.com
#
# *** Copyright Splunk, Inc. 2010
#

####   Execute an OS level command and return its output ####

def os_exec(cmd, stop_on_error):
    (cmd_status, cmd_output) = commands.getstatusoutput(cmd)
    if cmd_status != 0 and stop_on_error:
        print "Command failed: ", cmd
        print "Status: ", cmd_status
        sys.exit("Abnormal Termination.")
    return(cmd_output)

####   Given a username, see if it exists in /etc/passwd ####

def account_exists(inAcctName):
    inPwdStruc = pwd.getpwall()
    for a in inPwdStruc:
        if inAcctName == a.pw_name:
            return(True)
    return (False)

#####  Get the list of student names from --names or the file specified ###
def get_student_names(namesString, argList):
    student_array = []

    if namesString != "" and namesString != "None":
        namesString =namesString.strip().lower()
        student_array=namesString.split()
    else:
        if len(argList) < 1:
            print "Error: you must specify either a file name on the command line"
            print "       or the --names option"
            sys.exit(" Exiting with syntax error")
        else:
            namesFile=argList[0]
            if os.access(namesFile,os.R_OK):
                nFile = open(namesFile,'r')
                for inputLine in nFile:
                    if inputLine.strip() != "":
                        temp_array=inputLine.split()
                        new_name = temp_array[0].lower()
                        if student_array == None:
                            student_array = [ new_name ]
                        else:
                            if new_name in student_array:
                                print "Warning: duplicate name " + new_name + " was ignored."
                            else:
                                student_array.append(new_name)
                nFile.close()
            else:
                print "Error: invalid file name for list of student names"
                print " File: " + namesFile + " could not be read"
    return(student_array)

######### Read in existing students_file                            ##########
def read_students_file(students_file):
    student_list = []
    pass_list = []
    port_list = []

    if os.access(students_file,os.R_OK):
        sFile = open(students_file,'r')
        for inputLine in sFile:
            if inputLine[0] != "#" and inputLine.strip() != "":
                temp_array=inputLine.strip().split()
                if student_list == None:
                    student_list = [ temp_array[0] ]
                    pass_list = [ temp_array[1] ]
                    port_list = [ int(temp_array[2]) ]
                else:
                    student_list.append(temp_array[0])
                    pass_list.append(temp_array[1])
                    port_list.append(temp_array[2])
        sFile.close()
    return (student_list, pass_list, port_list)

###  append new students to the existing students file (create it if id does ###
###  not exist yet                                                           ###
def append_students_file(students_file, student_array, pass_array, port_array):
    if os.path.exists(students_file):
        sFile = open(students_file, 'a')
    else:
        sFile = open(students_file, 'w')
        sFile.write ("# this file is automatically generated.\n")
        sFile.write ("# please take care if editing manually\n\n")
        sFile.write("#ACCOUNT PASSWORD PORT\n\n")

    for i in range(len(student_array)):
        sFile.write(student_array[i] + " " + pass_array[i] + " " + str(port_array[i]) + "\n")

    sFile.close()

##### rewrite the students file, eliminating the students that should be #####
##### deleted
def delete_from_students_file(students_file, students_to_delete):
    #read the current file
    (student_list, pass_list, port_list) = read_students_file(students_file)

    #delete the current file
    os_exec("rm -f " + students_file, True)

    #write the updated version
    sFile = open(students_file, 'w')
    sFile.write ("# this file is automatically generated.\n")
    sFile.write ("# please take care if editing manually\n\n")
    sFile.write("#ACCOUNT PASSWORD PORT\n\n")

    for i in range(len(student_list)):
        if not student_list[i] in students_to_delete:
            sFile.write(student_list[i] + " " + pass_list[i] + " " + str(port_list[i]) + "\n")

    sFile.close()

###  read defaults file and make a dictionary of its entries              ###
# read in the defaults for the arguments from the defaults file
def process_defaults_file(curDirectory):
    defaults = {}
    defaultFile = curDirectory + '/default'
    if os.access(defaultFile,os.R_OK):
        dFile = open(defaultFile,'r')
        for inputLine in dFile:
            pos=inputLine.find('=')
            if pos > 0:
                 optionName = inputLine[:pos].strip()
                 optionValue = inputLine[pos+1:].strip()
                 defaults[optionName] = optionValue
    else:
        print "Error: Missing defaults file."
        sys.exit("Exiting")
    return (defaults)

#### stop Splunk for the given account name ###
def stop_splunk(inAcctName):
    if account_exists(inAcctName):
        homeDir=pwd.getpwnam(inAcctName)[5]
        os_exec(homeDir + "/splunk/bin/splunk stop", False)

#### stop Splunk forwarder for the given account name ###
#### student and forwarder directories
def stop_splunk_fwd(inAcctName):
    if account_exists(inAcctName):
        homeDir=pwd.getpwnam(inAcctName)[5]
        os_exec(homeDir + "/splunkforwarder/bin/splunk stop", False)

#### start Splunk for the given account name                       ####
def start_splunk(inAcctName):
    if account_exists(inAcctName):
        homeDir = pwd.getpwnam(inAcctName)[5]
        args = [ "su",  "-c", homeDir + "/splunk/bin/splunk start --accept-license", inAcctName ]
        p = subprocess.Popen(args)
        cmd_status = os.waitpid(p.pid, 0)[1]
        if cmd_status != 0:
            print "Command failed: ", args
            print "Status: ", cmd_status
            sys.exit(int(cmd_status))

# copy_files is used to move files into the Splunk etc directory
# the local.meta file is not simply copied, but appended to any existing
#    local.meta (if there is a local.meta in the files to be copied)
def copy_files(configDir, destination):
    metafile="etc/apps/search/metadata/local.meta"

    if configDir[-1] != "/":
        configDir = configDir + "/"

    for root, dirs, files in os.walk(configDir):

        relPath = root.replace(configDir,"",1) # root - configDir to get relative path

        for f in files:
            d = os.path.join(destination, relPath)
            if not os.access(d, os.F_OK | os.W_OK):
                os_exec("mkdir -p " + d, True)

            f = os.path.join(relPath, f)
            if f == metafile:
                # append this metafile to the existing meta file
                os_exec("cat " + configDir + f + " >>" + destination + f, True)
            else:
                os_exec("cp " + configDir + f + " " + destination + f, True)

def munge_apache(students_file):
    # re read file before writing apahce conf
    (existing_students, existing_pass, existing_ports) = read_students_file(students_file)
    ports2munge = []
    # generate default port list
    rports = range(950, 971)
    for port in rports:
            ports2munge.append(str(port*10))
    # convert list to set
    sp2m = set(ports2munge)
    sp = set(existing_ports)
    # subtract existing ports from default list
    diff = sp2m - sp
    list = []
    # create the file (the sloppy way)
    os.system("touch /tmp/ports")
    os.system("cat /dev/null > /tmp/ports")
    # sort ports and write to a temp ports file (sloppy)
    for port in diff:
            list.append(port)
    for port in sorted(list):
            os.system("echo \"Listen " + port + "\" >> /tmp/ports")
    print "updating apache config"
    # construct temp httpd.conf file
    os.system("cat httpd.conf_header > /tmp/httpd.conf")
    os.system("cat /tmp/ports >> /tmp/httpd.conf")
    os.system("cat httpd.conf_footer >> /tmp/httpd.conf")
    # copy to proper apache folder
    os.system("cp /tmp/httpd.conf /etc/httpd/conf/httpd.conf")

    print "restarting apache"
    os.system("/usr/sbin/apachectl restart")
    print "apache restarted"
